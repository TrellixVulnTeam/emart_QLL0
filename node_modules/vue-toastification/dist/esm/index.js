import { defineComponent, toRaw, unref, openBlock, createBlock, resolveDynamicComponent, mergeProps, withCtx, createTextVNode, createVNode, toDisplayString, resolveComponent, createCommentVNode, Fragment, toHandlers, withModifiers, TransitionGroup, renderSlot, renderList, nextTick, createApp, provide, getCurrentInstance, inject } from 'vue';

const isFunction = value => typeof value === "function";

const isString = value => typeof value === "string";

const isNonEmptyString = value => isString(value) && value.trim().length > 0;

const isNumber = value => typeof value === "number";

const isUndefined = value => typeof value === "undefined";

const isObject = value => typeof value === "object" && value !== null;

const isJSX = obj => hasProp(obj, "tag") && isNonEmptyString(obj.tag);

const isTouchEvent = event => window.TouchEvent && event instanceof TouchEvent;

const isToastComponent = obj => hasProp(obj, "component") && isToastContent(obj.component);

const isVueComponent = c => isFunction(c) || isObject(c);

const isToastContent = obj => // Ignore undefined
!isUndefined(obj) && ( // Is a string
isString(obj) || // Regular Vue component
isVueComponent(obj) || // Nested object
isToastComponent(obj));

const isDOMRect = obj => isObject(obj) && ["height", "width", "right", "left", "top", "bottom"].every(p => isNumber(obj[p]));

const hasProp = (obj, propKey) => (isObject(obj) || isFunction(obj)) && propKey in obj;
/**
 * ID generator
 */


const getId = (i => () => i++)(0);

function getX(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
}

function getY(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
}

const removeElement = el => {
  if (!isUndefined(el.remove)) {
    el.remove();
  } else if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};

const getVueComponentFromObj = obj => {
  if (isToastComponent(obj)) {
    // Recurse if component prop
    return getVueComponentFromObj(obj.component);
  }

  if (isJSX(obj)) {
    // Create render function for JSX
    return defineComponent({
      render() {
        return obj;
      }

    });
  } // Return regular string or raw object


  return typeof obj === "string" ? obj : toRaw(unref(obj));
};

const normalizeToastComponent = obj => {
  if (typeof obj === "string") {
    return obj;
  }

  const props = hasProp(obj, "props") && isObject(obj.props) ? obj.props : {};
  const listeners = hasProp(obj, "listeners") && isObject(obj.listeners) ? obj.listeners : {};
  return {
    component: getVueComponentFromObj(obj),
    props,
    listeners
  };
};

const isBrowser = () => typeof window !== "undefined";

class EventBus {
  constructor() {
    this.allHandlers = {};
  }

  getHandlers(eventType) {
    return this.allHandlers[eventType] || [];
  }

  on(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.push(handler);
    this.allHandlers[eventType] = handlers;
  }

  off(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.splice(handlers.indexOf(handler) >>> 0, 1);
  }

  emit(eventType, event) {
    const handlers = this.getHandlers(eventType);
    handlers.forEach(handler => handler(event));
  }

}
const isEventBusInterface = e => ["on", "off", "emit"].every(f => hasProp(e, f) && isFunction(e[f]));

var TYPE;

(function (TYPE) {
  TYPE["SUCCESS"] = "success";
  TYPE["ERROR"] = "error";
  TYPE["WARNING"] = "warning";
  TYPE["INFO"] = "info";
  TYPE["DEFAULT"] = "default";
})(TYPE || (TYPE = {}));

var POSITION;

(function (POSITION) {
  POSITION["TOP_LEFT"] = "top-left";
  POSITION["TOP_CENTER"] = "top-center";
  POSITION["TOP_RIGHT"] = "top-right";
  POSITION["BOTTOM_LEFT"] = "bottom-left";
  POSITION["BOTTOM_CENTER"] = "bottom-center";
  POSITION["BOTTOM_RIGHT"] = "bottom-right";
})(POSITION || (POSITION = {}));

var EVENTS;

(function (EVENTS) {
  EVENTS["ADD"] = "add";
  EVENTS["DISMISS"] = "dismiss";
  EVENTS["UPDATE"] = "update";
  EVENTS["CLEAR"] = "clear";
  EVENTS["UPDATE_DEFAULTS"] = "update_defaults";
})(EVENTS || (EVENTS = {}));

const VT_NAMESPACE = "Vue-Toastification";

const COMMON = {
  type: {
    type: String,
    default: TYPE.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
};
const ICON = {
  type: COMMON.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
};
const CLOSE_BUTTON = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: COMMON.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
};
const PROGRESS_BAR = {
  timeout: {
    type: [Number, Boolean],
    default: 5000
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
};
const TRANSITION = {
  transition: {
    type: [Object, String],
    default: `${VT_NAMESPACE}__bounce`
  }
};
const CORE_TOAST = {
  position: {
    type: String,
    default: POSITION.TOP_RIGHT
  },
  draggable: COMMON.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: COMMON.trueBoolean,
  pauseOnHover: COMMON.trueBoolean,
  closeOnClick: COMMON.trueBoolean,
  timeout: PROGRESS_BAR.timeout,
  hideProgressBar: PROGRESS_BAR.hideProgressBar,
  toastClassName: COMMON.classNames,
  bodyClassName: COMMON.classNames,
  icon: ICON.customIcon,
  closeButton: CLOSE_BUTTON.component,
  closeButtonClassName: CLOSE_BUTTON.classNames,
  showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: true,
    default: new EventBus()
  }
};
const TOAST = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: COMMON.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: () => {}
  },
  onClose: {
    type: Function,
    default:
    /* istanbul ignore next */
    () => {}
  }
};
const CONTAINER = {
  container: {
    type: [HTMLElement, Function],
    default: () => document.body
  },
  newestOnTop: COMMON.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: TRANSITION.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: toast => toast
  },
  filterToasts: {
    type: Function,
    default: toasts => toasts
  },
  containerClassName: COMMON.classNames,
  onMounted: Function
};
var PROPS = {
  CORE_TOAST,
  TOAST,
  CONTAINER,
  PROGRESS_BAR,
  ICON,
  TRANSITION,
  CLOSE_BUTTON
};

var script = defineComponent({
  name: "VtProgressBar",
  props: PROPS.PROGRESS_BAR,

  // TODO: The typescript compiler is not playing nice with emit types
  // Rollback this change once ts is able to infer emit types
  // emits: ["close-toast"],
  data() {
    return {
      hasClass: true
    };
  },

  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },

    cpClass() {
      return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
    }

  },
  watch: {
    timeout() {
      this.hasClass = false;
      this.$nextTick(() => this.hasClass = true);
    }

  },

  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },

  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },

  methods: {
    animationEnded() {
      // See TODO on line 16
      // eslint-disable-next-line vue/require-explicit-emits
      this.$emit("close-toast");
    }

  }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    style: _ctx.style,
    class: _ctx.cpClass
  }, null, 6 /* CLASS, STYLE */))
}

script.render = render;
script.__file = "src/components/VtProgressBar.vue";

var script$1 = defineComponent({
  name: "VtCloseButton",
  props: PROPS.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      if (this.component !== false) {
        return getVueComponentFromObj(this.component);
      }

      return "button";
    },

    classes() {
      const classes = [`${VT_NAMESPACE}__close-button`];

      if (this.showOnHover) {
        classes.push("show-on-hover");
      }

      return classes.concat(this.classNames);
    }

  }
});

const _hoisted_1 = /*#__PURE__*/createTextVNode(" Ã— ");

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
    "aria-label": _ctx.ariaLabel,
    class: _ctx.classes
  }, _ctx.$attrs), {
    default: withCtx(() => [
      _hoisted_1
    ]),
    _: 1
  }, 16 /* FULL_PROPS */, ["aria-label", "class"]))
}

script$1.render = render$1;
script$1.__file = "src/components/VtCloseButton.vue";

var script$2 = {};

const _hoisted_1$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2 = /*#__PURE__*/createVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1 /* HOISTED */);

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("svg", _hoisted_1$1, [
    _hoisted_2
  ]))
}

script$2.render = render$2;
script$2.__file = "src/components/icons/VtSuccessIcon.vue";

var script$3 = {};

const _hoisted_1$2 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$1 = /*#__PURE__*/createVNode("path", {
  fill: "currentColor",
  d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1 /* HOISTED */);

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("svg", _hoisted_1$2, [
    _hoisted_2$1
  ]))
}

script$3.render = render$3;
script$3.__file = "src/components/icons/VtInfoIcon.vue";

var script$4 = {};

const _hoisted_1$3 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$2 = /*#__PURE__*/createVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1 /* HOISTED */);

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("svg", _hoisted_1$3, [
    _hoisted_2$2
  ]))
}

script$4.render = render$4;
script$4.__file = "src/components/icons/VtWarningIcon.vue";

var script$5 = {};

const _hoisted_1$4 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
const _hoisted_2$3 = /*#__PURE__*/createVNode("path", {
  fill: "currentColor",
  d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1 /* HOISTED */);

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("svg", _hoisted_1$4, [
    _hoisted_2$3
  ]))
}

script$5.render = render$5;
script$5.__file = "src/components/icons/VtErrorIcon.vue";

var script$6 = defineComponent({
  name: "VtIcon",
  props: PROPS.ICON,
  computed: {
    customIconChildren() {
      return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },

    customIconClass() {
      if (isString(this.customIcon)) {
        return this.trimValue(this.customIcon);
      } else if (hasProp(this.customIcon, "iconClass")) {
        return this.trimValue(this.customIcon.iconClass);
      }

      return "";
    },

    customIconTag() {
      if (hasProp(this.customIcon, "iconTag")) {
        return this.trimValue(this.customIcon.iconTag, "i");
      }

      return "i";
    },

    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },

    component() {
      if (this.hasCustomIcon) {
        return this.customIconTag;
      }

      if (isToastContent(this.customIcon)) {
        return getVueComponentFromObj(this.customIcon);
      }

      return this.iconTypeComponent;
    },

    iconTypeComponent() {
      const types = {
        [TYPE.DEFAULT]: script$3,
        [TYPE.INFO]: script$3,
        [TYPE.SUCCESS]: script$2,
        [TYPE.ERROR]: script$5,
        [TYPE.WARNING]: script$4
      };
      return types[this.type];
    },

    iconClasses() {
      const classes = [`${VT_NAMESPACE}__icon`];

      if (this.hasCustomIcon) {
        return classes.concat(this.customIconClass);
      }

      return classes;
    }

  },
  methods: {
    trimValue(value, empty = "") {
      return isNonEmptyString(value) ? value.trim() : empty;
    }

  }
});

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent(_ctx.component), { class: _ctx.iconClasses }, {
    default: withCtx(() => [
      createTextVNode(toDisplayString(_ctx.customIconChildren), 1 /* TEXT */)
    ]),
    _: 1
  }, 8 /* PROPS */, ["class"]))
}

script$6.render = render$6;
script$6.__file = "src/components/VtIcon.vue";

var script$7 = defineComponent({
  name: "VtToast",
  components: {
    ProgressBar: script,
    CloseButton: script$1,
    Icon: script$6
  },
  inheritAttrs: false,
  props: Object.assign({}, PROPS.CORE_TOAST, PROPS.TOAST),

  data() {
    const data = {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: {
        x: 0,
        y: 0
      },
      dragRect: {}
    };
    return data;
  },

  computed: {
    classes() {
      const classes = [`${VT_NAMESPACE}__toast`, `${VT_NAMESPACE}__toast--${this.type}`, `${this.position}`].concat(this.toastClassName);

      if (this.disableTransitions) {
        classes.push("disable-transition");
      }

      if (this.rtl) {
        classes.push(`${VT_NAMESPACE}__toast--rtl`);
      }

      return classes;
    },

    bodyClasses() {
      const classes = [`${VT_NAMESPACE}__toast-${isString(this.content) ? "body" : "component-body"}`].concat(this.bodyClassName);
      return classes;
    },

    /* istanbul ignore next */
    draggableStyle() {
      if (this.dragStart === this.dragPos.x) {
        return {};
      } else if (this.beingDragged) {
        return {
          transform: `translateX(${this.dragDelta}px)`,
          opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
        };
      } else {
        return {
          transition: "transform 0.2s, opacity 0.2s",
          transform: "translateX(0)",
          opacity: 1
        };
      }
    },

    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },

    removalDistance() {
      if (isDOMRect(this.dragRect)) {
        return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
      }

      return 0;
    }

  },

  mounted() {
    if (this.draggable) {
      this.draggableSetup();
    }

    if (this.pauseOnFocusLoss) {
      this.focusSetup();
    }
  },

  beforeUnmount() {
    if (this.draggable) {
      this.draggableCleanup();
    }

    if (this.pauseOnFocusLoss) {
      this.focusCleanup();
    }
  },

  methods: {
    getVueComponentFromObj,

    closeToast() {
      this.eventBus.emit(EVENTS.DISMISS, this.id);
    },

    clickHandler() {
      if (this.onClick) {
        this.onClick(this.closeToast);
      }

      if (this.closeOnClick) {
        if (!this.beingDragged || this.dragStart === this.dragPos.x) {
          this.closeToast();
        }
      }
    },

    timeoutHandler() {
      this.closeToast();
    },

    hoverPause() {
      if (this.pauseOnHover) {
        this.isRunning = false;
      }
    },

    hoverPlay() {
      if (this.pauseOnHover) {
        this.isRunning = true;
      }
    },

    focusPause() {
      this.isRunning = false;
    },

    focusPlay() {
      this.isRunning = true;
    },

    focusSetup() {
      addEventListener("blur", this.focusPause);
      addEventListener("focus", this.focusPlay);
    },

    focusCleanup() {
      removeEventListener("blur", this.focusPause);
      removeEventListener("focus", this.focusPlay);
    },

    draggableSetup() {
      const element = this.$el;
      element.addEventListener("touchstart", this.onDragStart, {
        passive: true
      });
      element.addEventListener("mousedown", this.onDragStart);
      addEventListener("touchmove", this.onDragMove, {
        passive: false
      });
      addEventListener("mousemove", this.onDragMove);
      addEventListener("touchend", this.onDragEnd);
      addEventListener("mouseup", this.onDragEnd);
    },

    draggableCleanup() {
      const element = this.$el;
      element.removeEventListener("touchstart", this.onDragStart);
      element.removeEventListener("mousedown", this.onDragStart);
      removeEventListener("touchmove", this.onDragMove);
      removeEventListener("mousemove", this.onDragMove);
      removeEventListener("touchend", this.onDragEnd);
      removeEventListener("mouseup", this.onDragEnd);
    },

    onDragStart(event) {
      this.beingDragged = true;
      this.dragPos = {
        x: getX(event),
        y: getY(event)
      };
      this.dragStart = getX(event);
      this.dragRect = this.$el.getBoundingClientRect();
    },

    onDragMove(event) {
      if (this.beingDragged) {
        event.preventDefault();

        if (this.isRunning) {
          this.isRunning = false;
        }

        this.dragPos = {
          x: getX(event),
          y: getY(event)
        };
      }
    },

    onDragEnd() {
      if (this.beingDragged) {
        if (Math.abs(this.dragDelta) >= this.removalDistance) {
          this.disableTransitions = true;
          this.$nextTick(() => this.closeToast());
        } else {
          setTimeout(() => {
            this.beingDragged = false;

            if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
              this.isRunning = false;
            } else {
              this.isRunning = true;
            }
          });
        }
      }
    }

  }
});

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CloseButton = resolveComponent("CloseButton");
  const _component_ProgressBar = resolveComponent("ProgressBar");

  return (openBlock(), createBlock("div", {
    class: _ctx.classes,
    style: _ctx.draggableStyle,
    onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.clickHandler(...args))),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => (_ctx.hoverPause(...args))),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => (_ctx.hoverPlay(...args)))
  }, [
    (_ctx.icon)
      ? (openBlock(), createBlock(_component_Icon, {
          key: 0,
          "custom-icon": _ctx.icon,
          type: _ctx.type
        }, null, 8 /* PROPS */, ["custom-icon", "type"]))
      : createCommentVNode("v-if", true),
    createVNode("div", {
      role: _ctx.accessibility.toastRole || 'alert',
      class: _ctx.bodyClasses
    }, [
      (typeof _ctx.content === 'string')
        ? (openBlock(), createBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.content), 1 /* TEXT */)
          ], 64 /* STABLE_FRAGMENT */))
        : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
            key: 1,
            "toast-id": _ctx.id
          }, _ctx.content.props, toHandlers(_ctx.content.listeners), { onCloseToast: _ctx.closeToast }), null, 16 /* FULL_PROPS */, ["toast-id", "onCloseToast"]))
    ], 10 /* CLASS, PROPS */, ["role"]),
    (!!_ctx.closeButton)
      ? (openBlock(), createBlock(_component_CloseButton, {
          key: 1,
          component: _ctx.closeButton,
          "class-names": _ctx.closeButtonClassName,
          "show-on-hover": _ctx.showCloseButtonOnHover,
          "aria-label": _ctx.accessibility.closeButtonLabel,
          onClick: withModifiers(_ctx.closeToast, ["stop"])
        }, null, 8 /* PROPS */, ["component", "class-names", "show-on-hover", "aria-label", "onClick"]))
      : createCommentVNode("v-if", true),
    (_ctx.timeout)
      ? (openBlock(), createBlock(_component_ProgressBar, {
          key: 2,
          "is-running": _ctx.isRunning,
          "hide-progress-bar": _ctx.hideProgressBar,
          timeout: _ctx.timeout,
          onCloseToast: _ctx.timeoutHandler
        }, null, 8 /* PROPS */, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"]))
      : createCommentVNode("v-if", true)
  ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */))
}

script$7.render = render$7;
script$7.__file = "src/components/VtToast.vue";

// Transition methods taken from https://github.com/BinarCode/vue2-transitions
var script$8 = defineComponent({
  name: "VtTransition",
  props: PROPS.TRANSITION,
  emits: ["leave"],
  methods: {
    leave(el) {
      el.style.left = el.offsetLeft + "px";
      el.style.top = el.offsetTop + "px";
      el.style.width = getComputedStyle(el).width;
      el.style.position = "absolute";
    }

  }
});

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": 
      _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`
    ,
    "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
    "leave-active-class": 
      _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`
    ,
    onLeave: _ctx.leave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8 /* PROPS */, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]))
}

script$8.render = render$8;
script$8.__file = "src/components/VtTransition.vue";

var script$9 = defineComponent({
  name: "VueToastification",
  components: {
    Toast: script$7,
    VtTransition: script$8
  },
  props: Object.assign({}, PROPS.CORE_TOAST, PROPS.CONTAINER, PROPS.TRANSITION),

  data() {
    const data = {
      count: 0,
      positions: Object.values(POSITION),
      toasts: {},
      defaults: {}
    };
    return data;
  },

  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },

    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }

  },

  beforeMount() {
    const events = this.eventBus;
    events.on(EVENTS.ADD, this.addToast);
    events.on(EVENTS.CLEAR, this.clearToasts);
    events.on(EVENTS.DISMISS, this.dismissToast);
    events.on(EVENTS.UPDATE, this.updateToast);
    events.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
    this.defaults = this.$props;
  },

  mounted() {
    this.setup(this.container);
  },

  methods: {
    async setup(container) {
      if (isFunction(container)) {
        container = await container();
      }

      removeElement(this.$el);
      container.appendChild(this.$el);
    },

    setToast(props) {
      if (!isUndefined(props.id)) {
        this.toasts[props.id] = props;
      }
    },

    addToast(params) {
      params.content = normalizeToastComponent(params.content);
      const props = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
      const toast = this.defaults.filterBeforeCreate(props, this.toastArray);
      toast && this.setToast(toast);
    },

    dismissToast(id) {
      const toast = this.toasts[id];

      if (!isUndefined(toast) && !isUndefined(toast.onClose)) {
        toast.onClose();
      }

      delete this.toasts[id];
    },

    clearToasts() {
      Object.keys(this.toasts).forEach(id => {
        this.dismissToast(id);
      });
    },

    getPositionToasts(position) {
      const toasts = this.filteredToasts.filter(toast => toast.position === position).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? toasts.reverse() : toasts;
    },

    updateDefaults(update) {
      // Update container if changed
      if (!isUndefined(update.container)) {
        this.setup(update.container);
      }

      this.defaults = Object.assign({}, this.defaults, update);
    },

    updateToast({
      id,
      options,
      create
    }) {
      if (this.toasts[id]) {
        // If a timeout is defined, and is equal to the one before, change it
        // a little so the progressBar is reset
        if (options.timeout && options.timeout === this.toasts[id].timeout) {
          options.timeout++;
        }

        this.setToast(Object.assign({}, this.toasts[id], options));
      } else if (create) {
        this.addToast(Object.assign({}, {
          id
        }, options));
      }
    },

    getClasses(position) {
      const classes = [`${VT_NAMESPACE}__container`, position];
      return classes.concat(this.defaults.containerClassName);
    }

  }
});

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Toast = resolveComponent("Toast");
  const _component_VtTransition = resolveComponent("VtTransition");

  return (openBlock(), createBlock("div", null, [
    (openBlock(true), createBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
      return (openBlock(), createBlock("div", { key: pos }, [
        createVNode(_component_VtTransition, {
          transition: _ctx.defaults.transition,
          class: _ctx.getClasses(pos)
        }, {
          default: withCtx(() => [
            (openBlock(true), createBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast) => {
              return (openBlock(), createBlock(_component_Toast, mergeProps({
                key: toast.id
              }, toast), null, 16 /* FULL_PROPS */))
            }), 128 /* KEYED_FRAGMENT */))
          ]),
          _: 2
        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["transition", "class"])
      ]))
    }), 128 /* KEYED_FRAGMENT */))
  ]))
}

script$9.render = render$9;
script$9.__file = "src/components/VtToastContainer.vue";

const buildInterface = (globalOptions = {}, mountContainer = true) => {
  const events = globalOptions.eventBus = globalOptions.eventBus || new EventBus();

  if (mountContainer) {
    nextTick(() => {
      const app = createApp(script$9, Object.assign({}, globalOptions));
      const component = app.mount(document.createElement("div"));
      const onMounted = globalOptions.onMounted;

      if (!isUndefined(onMounted)) {
        onMounted(component, app);
      }
    });
  }
  /**
   * Display a toast
   */


  const toast = (content, options) => {
    const props = Object.assign({}, {
      id: getId(),
      type: TYPE.DEFAULT
    }, options, {
      content
    });
    events.emit(EVENTS.ADD, props);
    return props.id;
  };
  /**
   * Clear all toasts
   */


  toast.clear = () => events.emit(EVENTS.CLEAR, undefined);
  /**
   * Update Plugin Defaults
   */


  toast.updateDefaults = update => {
    events.emit(EVENTS.UPDATE_DEFAULTS, update);
  };
  /**
   * Dismiss toast specified by an id
   */


  toast.dismiss = id => {
    events.emit(EVENTS.DISMISS, id);
  };

  function updateToast(id, {
    content,
    options
  }, create = false) {
    const opt = Object.assign({}, options, {
      content
    });
    events.emit(EVENTS.UPDATE, {
      id,
      options: opt,
      create
    });
  }

  toast.update = updateToast;
  /**
   * Display a success toast
   */

  toast.success = (content, options) => toast(content, Object.assign({}, options, {
    type: TYPE.SUCCESS
  }));
  /**
   * Display an info toast
   */


  toast.info = (content, options) => toast(content, Object.assign({}, options, {
    type: TYPE.INFO
  }));
  /**
   * Display an error toast
   */


  toast.error = (content, options) => toast(content, Object.assign({}, options, {
    type: TYPE.ERROR
  }));
  /**
   * Display a warning toast
   */


  toast.warning = (content, options) => toast(content, Object.assign({}, options, {
    type: TYPE.WARNING
  }));

  return toast;
};

const createMockToastInterface = () => {
  const toast = () => console.warn("[Vue Toastification] This plugin does not support SSR!");

  return new Proxy(toast, {
    get() {
      return toast;
    }

  });
};

function createToastInterface(optionsOrEventBus) {
  if (!isBrowser()) {
    return createMockToastInterface();
  }

  if (isEventBusInterface(optionsOrEventBus)) {
    return buildInterface({
      eventBus: optionsOrEventBus
    }, false);
  }

  return buildInterface(optionsOrEventBus, true);
}

const toastInjectionKey = Symbol("VueToastification");
const globalEventBus = new EventBus();

const VueToastificationPlugin = (App, options) => {
  const inter = createToastInterface(Object.assign({
    eventBus: globalEventBus
  }, options));
  App.provide(toastInjectionKey, inter);
};

const provideToast = options => {
  const toast = createToastInterface(options);
  provide(toastInjectionKey, toast);
};

const useToast = eventBus => {
  if (eventBus) {
    return createToastInterface(eventBus);
  }

  const toast = getCurrentInstance() ? inject(toastInjectionKey) : undefined;
  return toast ? toast : createToastInterface(globalEventBus);
};

export default VueToastificationPlugin;
export { EventBus, POSITION, TYPE, createToastInterface, globalEventBus, provideToast, toastInjectionKey, useToast };
//# sourceMappingURL=index.js.map
